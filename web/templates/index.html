<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AutoGLM Console</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        dark: '#1a1a1a',
                        darker: '#111111',
                        accent: '#2CC985',
                        accent_hover: '#229966',
                        glass: 'rgba(255, 255, 255, 0.05)'
                    }
                }
            }
        }
    </script>
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #111; color: #eee; }
        .glass-panel {
            background: rgba(30, 30, 30, 0.6);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .scrollbar-hide::-webkit-scrollbar { display: none; }
        .animate-pulse-slow { animation: pulse 3s cubic-bezier(0.4, 0, 0.6, 1) infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: .5; } }
        .animate-fade-in { animation: fadeIn 0.3s ease-out; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

        /* Timeline Styles */
        .timeline-container { 
            position: relative; 
            padding-left: 24px; 
            margin-top: 16px; 
            margin-bottom: 24px;
            display: flex;
            flex-direction: column;
        }
        /* Loading indicator always at the end visually */
        .timeline-container .task-loading-indicator { order: 9999; }
        /* All other content before loading */
        .timeline-container > *:not(.task-loading-indicator):not(.timeline-line) { order: 1; }
        .timeline-line {
            position: absolute; left: 11px; top: 10px; bottom: 0;
            width: 2px; background: rgba(255,255,255,0.05);
            border-radius: 99px;
        }
        .task-node { margin-bottom: 12px; position: relative; }
        .task-node-header {
            display: flex; align-items: center; gap: 12px;
            padding: 10px 14px;
            background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.05);
            border-radius: 12px; cursor: pointer; transition: all 0.2s;
        }
        .task-node-header:hover { background: rgba(255,255,255,0.06); }
        
        /* Node Types */
        .node-icon { 
            width: 24px; height: 24px; border-radius: 50%; 
            display: flex; align-items: center; justify-content: center;
            font-size: 12px; flex-shrink: 0; position: relative; z-index: 10;
        }
        .type-thought .node-icon { background: rgba(255,255,255,0.1); color: #9ca3af; border: 1px solid rgba(255,255,255,0.1); }
        .type-tool .node-icon { background: rgba(59, 130, 246, 0.1); color: #60a5fa; border: 1px solid rgba(59, 130, 246, 0.2); }
        .type-result .node-icon { background: rgba(34, 197, 94, 0.1); color: #4ade80; border: 1px solid rgba(34, 197, 94, 0.2); }

        /* Icon Connector (Dot on Timeline) */
        .node-connector {
            position: absolute; left: -25px; top: 18px;
            width: 8px; height: 8px; border-radius: 50%;
            background: #333; border: 2px solid #555;
            z-index: 5;
        }
        .active-task .timeline-line { background: linear-gradient(to bottom, #2CC985, rgba(255,255,255,0.05)); }
        
        .node-details {
            margin-top: 8px; margin-left: 36px;
            background: rgba(0,0,0,0.3); border-radius: 8px;
            padding: 12px; font-family: monospace; font-size: 11px;
            border: 1px solid rgba(255,255,255,0.05);
            display: none; /* Hidden by default */
        }
        .node-details.open { display: block; animation: fadeIn 0.2s; }
        
        .arrow-icon { transition: transform 0.2s; }
        .open .arrow-icon { transform: rotate(90deg); }

        /* Status Icons */
        .status-marker { margin-left: auto; display: flex; align-items: center; justify-content: center; width: 16px; height: 16px; }
        .status-loading { 
            border: 2px solid rgba(255,255,255,0.1); border-top-color: #2CC985; 
            border-radius: 50%; width: 100%; height: 100%; 
            animation: spin 1s linear infinite; 
        }
        .status-done { color: #2CC985; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body class="h-screen flex overflow-hidden selection:bg-accent selection:text-black">

    <!-- Sidebar: Profiles -->
    <div class="w-72 bg-darker border-r border-white/10 flex flex-col z-20 transition-all duration-300">
        <div class="h-16 flex items-center px-6 border-b border-white/5">
            <div class="w-3 h-3 rounded-full bg-accent mr-3 shadow-[0_0_10px_#2CC985]"></div>
            <h1 class="font-bold text-lg tracking-wide">AutoGLM</h1>
        </div>

        <div class="flex-1 overflow-y-auto p-4 space-y-2" id="profile-list">
            <!-- Profiles injected by JS -->
        </div>

        <div class="p-4 border-t border-white/5">
            <button onclick="openModal()" class="w-full py-2 px-4 rounded bg-white/5 hover:bg-white/10 text-sm transition flex items-center justify-center gap-2 border border-white/5">
                <span>+</span> Add Service
            </button>
        </div>
    </div>

    <!-- Main Content -->
    <div class="flex-1 flex flex-col relative bg-gradient-to-br from-gray-900 via-[#0a0a0a] to-black overflow-hidden">
        
        <!-- App Header (New V3 Design) -->
        <div class="h-16 border-b border-white/5 flex items-center justify-between px-6 bg-white/5 backdrop-blur-md z-10 shrink-0">
            <div class="flex items-center gap-3">
                <div class="h-8 w-8 rounded-full bg-gradient-to-br from-green-400 to-emerald-600 flex items-center justify-center text-black font-bold shadow-lg shadow-green-500/20">AI</div>
                <div>
                    <h1 class="font-bold text-gray-100 tracking-tight">AutoGLM</h1>
                    <p id="header-status-text" class="text-[10px] text-gray-400 font-mono">System Ready</p>
                </div>
            </div>
            <div class="flex items-center gap-3">

                <div class="flex gap-3" id="status-dots">
                    <!-- ADB Capsule -->
                    <div class="flex items-center gap-2 px-3 py-1.5 rounded-full bg-white/5 border border-white/5 hover:bg-white/10 transition-colors cursor-help" title="Android Debug Bridge">
                        <svg class="w-3 h-3 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 18h.01M8 21h8a2 2 0 002-2V5a2 2 0 00-2-2H8a2 2 0 00-2 2v14a2 2 0 002 2z" /></svg>
                        <span class="text-[10px] uppercase font-bold text-gray-400 tracking-wider">ADB</span>
                        <div id="dot-adb" class="w-1.5 h-1.5 rounded-full bg-gray-600 transition-colors shadow-[0_0_8px_rgba(0,0,0,0)]"></div>
                    </div>

                    <!-- API Capsule -->
                    <div class="flex items-center gap-2 px-3 py-1.5 rounded-full bg-white/5 border border-white/5 hover:bg-white/10 transition-colors cursor-help" title="LLM API Service">
                         <svg class="w-3 h-3 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10" /></svg>
                        <span class="text-[10px] uppercase font-bold text-gray-400 tracking-wider">API</span>
                        <div id="dot-api" class="w-1.5 h-1.5 rounded-full bg-gray-600 transition-colors shadow-[0_0_8px_rgba(0,0,0,0)]"></div>
                    </div>

                    <!-- Agent Capsule -->
                    <div class="flex items-center gap-2 px-3 py-1.5 rounded-full bg-white/5 border border-white/5 hover:bg-white/10 transition-colors cursor-help" title="Agent Work Status">
                        <svg class="w-3 h-3 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z" /></svg>
                        <span id="text-agent" class="text-[10px] uppercase font-bold text-gray-400 tracking-wider">Ready</span>
                        <div id="dot-agent" class="w-1.5 h-1.5 rounded-full bg-gray-600 transition-colors shadow-[0_0_8px_rgba(0,0,0,0)]"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Middle Area: Split View -->
        <!-- Middle Area: Split View -->
        <div id="main-layout-area" class="flex-1 flex overflow-hidden relative z-0 pb-[100px] transition-all duration-300 ease-in-out"> <!-- PB determines space for input bar -->
            
            <!-- Timeline (Unified) -->
            <div id="chat-container" class="flex-1 flex-col overflow-y-auto p-6 space-y-6 scroll-smooth border-r border-white/5 relative bg-black/20">
                <!-- Welcome Message -->
                <div class="flex gap-4">
                    <div class="w-8 h-8 rounded-full bg-gradient-to-br from-green-400 to-emerald-600 flex-shrink-0 flex items-center justify-center text-black text-xs font-bold shadow-lg shadow-green-500/20">AI</div>
                    <div class="flex-1 space-y-2">
                        <div class="glass-panel p-4 rounded-2xl rounded-tl-none text-gray-200 border border-white/10 shadow-xl">
                            <p class="leading-relaxed">System Initializing... Select a service profile to begin.</p>
                        </div>
                    </div>
                </div>
            </div>

        </div>

        <!-- Terminal Drawer (Collapsible) -->
        <div id="terminal-drawer" class="absolute bottom-[90px] left-0 right-0 bg-[#0F0F0F] border-t border-white/10 transform translate-y-[120%] transition-transform duration-300 z-40 h-[300px] flex flex-col shadow-2xl">
            <div class="h-8 bg-[#1a1a1a] flex items-center justify-between px-4 border-b border-white/5">
                <span class="text-[10px] font-bold text-gray-500 uppercase tracking-wider">System Logs</span>
                <button onclick="toggleTerminal()" class="text-gray-500 hover:text-white">
                    <svg class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" /></svg>
                </button>
            </div>
            <div id="logs-content" class="flex-1 overflow-y-auto p-4 font-mono text-[11px] space-y-1 text-gray-400">
                <!-- Raw Logs go here -->
            </div>
        </div>

        <!-- Input Area (Fixed at bottom) -->
        <div id="input-container" class="absolute bottom-0 left-0 right-0 h-[90px] z-50 bg-gradient-to-t from-black via-black/90 to-transparent pt-4 px-6 flex items-start justify-center backdrop-blur-sm transition-all duration-300 ease-in-out">
             <div class="w-full max-w-4xl relative group flex gap-4">
                
                <!-- Left Control Group (Moved from Header) -->
                <div class="flex items-center gap-2">
                    <button id="btn-restart" class="h-[60px] w-[60px] rounded-xl bg-[#1a1a1a]/90 hover:bg-white/10 text-gray-400 hover:text-white transition-all border border-white/10 shadow-xl flex flex-col items-center justify-center gap-1 group/btn" title="Reset Agent">
                         <span class="text-xs font-bold font-mono group-hover/btn:text-red-400 transition-colors">RESET</span>
                         <svg class="w-4 h-4 group-hover/btn:rotate-180 transition-transform duration-500" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" /></svg>
                    </button>
                    
                    <button onclick="toggleTerminal()" class="h-[60px] w-[60px] rounded-xl bg-[#1a1a1a]/90 hover:bg-white/10 text-gray-400 hover:text-white transition-all border border-white/10 shadow-xl flex flex-col items-center justify-center gap-1 group/btn" title="Toggle Logs (Ctrl+\)">
                         <span class="text-xs font-bold font-mono group-hover/btn:text-accent transition-colors">LOGS</span>
                         <svg class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" /></svg>
                    </button>
                </div>

                <!-- Input Box -->
                <div class="relative flex-1 flex items-center bg-[#1a1a1a]/90 rounded-xl border border-white/10 shadow-xl backdrop-blur-md transition-all duration-200 focus-within:ring-1 focus-within:ring-green-500/50 focus-within:border-green-500/50 h-[60px]">
                    <span class="pl-5 text-green-500 font-mono text-xl animate-pulse pointer-events-none select-none">>_</span>
                    <input type="text" id="prompt-input" 
                        class="w-full bg-transparent border-none text-gray-100 placeholder-gray-600 focus:ring-0 px-4 h-full font-mono text-sm outline-none tracking-wide"
                        placeholder="Command the agent..." autocomplete="off">
                    
                    <!-- Controls -->
                    <div class="pr-3 flex gap-3 items-center h-full">
                        <button id="btn-stop" class="hidden px-4 py-1.5 rounded-lg bg-red-500/10 text-red-500 hover:bg-red-500/20 transition-all font-bold text-xs border border-red-500/20 flex items-center gap-2 uppercase tracking-wide">
                            <span class="w-1.5 h-1.5 bg-red-500 rounded-sm animate-pulse"></span>
                            Stop
                        </button>
                        <button id="btn-send" class="h-9 px-6 rounded-lg bg-green-500 hover:bg-green-400 text-black font-bold transition-all shadow-lg shadow-green-500/10 active:scale-95 flex items-center justify-center text-xs tracking-wide uppercase">
                            Send
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Right Sidebar: Live Screen (Preserved) -->
    <div class="w-[340px] bg-black/40 border-l border-white/5 backdrop-blur-md flex flex-col z-20 relative transition-all duration-300" id="screen-panel">
        <div class="h-16 flex items-center justify-between px-6 border-b border-white/5">
            <h2 class="font-bold text-sm tracking-wide text-gray-200">Live View</h2>
            <div class="flex gap-2 items-center">
                 <div class="h-1.5 w-1.5 rounded-full bg-red-500 animate-pulse shadow-[0_0_8px_#EF4444]" title="Live"></div>
            </div>
        </div>
        
        <div class="flex-1 flex items-center justify-center p-6 bg-[url('https://grainy-gradients.vercel.app/noise.svg')] bg-opacity-10 relative">
            <div id="screen-container" class="relative w-full aspect-[9/19] bg-black rounded-[2rem] border-4 border-gray-800 shadow-2xl overflow-hidden ring-1 ring-white/10 group touch-none select-none">
                <!-- Screen Image Stream -->
                <img id="screen-img" src="/api/screen/stream" class="w-full h-full object-cover opacity-90 group-hover:opacity-100 transition-opacity" alt="Device Screen">
                
                <!-- Interactive Overlay -->
                <div id="control-overlay" class="absolute inset-0 z-10 cursor-pointer active:cursor-move"></div>
            </div>
            
            <!-- Floating Control Bar -->
            <div class="absolute bottom-10 left-1/2 -translate-x-1/2 bg-black/60 backdrop-blur-md rounded-full px-4 py-2 flex gap-4 border border-white/10 shadow-xl opacity-0 hover:opacity-100 transition-opacity duration-300 z-30">
                <button onclick="sendKey(4)" class="p-2 text-gray-300 hover:text-white hover:bg-white/10 rounded-full transition" title="Back">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path></svg>
                </button>
                <button onclick="sendKey(3)" class="p-2 text-gray-300 hover:text-white hover:bg-white/10 rounded-full transition" title="Home">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6"></path></svg>
                </button>
                <button onclick="toggleTextInput()" class="p-2 text-gray-300 hover:text-white hover:bg-white/10 rounded-full transition" title="Type Text">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path></svg>
                </button>
            </div>
            
            <!-- Text Input Modal -->
            <div id="text-input-popover" class="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-black/90 rounded-xl p-4 border border-white/20 shadow-2xl hidden z-40 w-64 backdrop-blur">
                <input type="text" id="remote-input" class="w-full bg-white/10 rounded px-3 py-2 text-white outline-none focus:ring-1 focus:ring-accent mb-2 text-sm" placeholder="Type to send...">
                <div class="flex justify-end gap-2">
                    <button onclick="toggleTextInput()" class="px-3 py-1 text-xs text-gray-400 hover:text-white">Close</button>
                    <button onclick="sendTextInput()" class="px-3 py-1 text-xs bg-accent text-black rounded font-bold hover:bg-accent_hover">Send</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Right Sidebar: Live Screen (Preserved) -->

    
    <!-- Profile Modal (Preserved) -->
    <div id="profile-modal" class="fixed inset-0 bg-black/80 backdrop-blur-sm z-50 hidden flex items-center justify-center">
        <!-- ... (Same as before) ... -->
        <div class="glass-panel w-[450px] rounded-xl p-8 shadow-2xl border border-white/10 relative">
            <h2 id="modal-title" class="text-xl font-bold mb-6 text-white">Add Service</h2>
            <input type="hidden" id="p-index" value="-1">
            <div class="space-y-5">
                <div>
                    <label class="block text-xs text-gray-400 mb-1.5 uppercase tracking-wide font-semibold">Service Name</label>
                    <input id="p-name" type="text" class="w-full bg-black/50 border border-white/10 rounded-lg p-3 text-sm outline-none focus:border-accent focus:ring-1 focus:ring-accent/50 transition">
                </div>
                <div>
                    <label class="block text-xs text-gray-400 mb-1.5 uppercase tracking-wide font-semibold">Provider Interface</label>
                    <div class="relative">
                        <select id="p-provider" class="w-full bg-black/50 border border-white/10 rounded-lg p-3 text-sm outline-none focus:border-accent appearance-none text-gray-200">
                            <option value="OpenAI">OpenAI (Standard)</option>
                            <option value="OpenAI-Response">OpenAI-Response</option>
                            <option value="Gemini">Gemini</option>
                            <option value="Anthropic">Anthropic</option>
                        </select>
                         <div class="pointer-events-none absolute inset-y-0 right-0 flex items-center px-4 text-gray-400">
                            <svg class="fill-current h-4 w-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"/></svg>
                        </div>
                    </div>
                </div>
                <div>
                    <label class="block text-xs text-gray-400 mb-1.5 uppercase tracking-wide font-semibold">Base URL</label>
                    <input id="p-url" type="text" class="w-full bg-black/50 border border-white/10 rounded-lg p-3 text-sm outline-none focus:border-accent font-mono text-xs">
                </div>
                <div>
                    <label class="block text-xs text-gray-400 mb-1.5 uppercase tracking-wide font-semibold">API Key</label>
                    <input id="p-key" type="password" class="w-full bg-black/50 border border-white/10 rounded-lg p-3 text-sm outline-none focus:border-accent font-mono text-xs">
                </div>
                <div>
                    <label class="block text-xs text-gray-400 mb-1.5 uppercase tracking-wide font-semibold">Model Name</label>
                    <input id="p-model" type="text" class="w-full bg-black/50 border border-white/10 rounded-lg p-3 text-sm outline-none focus:border-accent font-mono text-xs">
                </div>
            </div>
            <div class="flex justify-end gap-3 mt-8">
                <button onclick="closeModal()" class="text-sm text-gray-400 hover:text-white transition px-4 py-2">Cancel</button>
                <button onclick="saveProfile()" class="bg-accent text-black font-bold text-sm px-6 py-2.5 rounded-lg hover:bg-accent_hover transition shadow-lg shadow-accent/20">Save Profile</button>
            </div>
        </div>
    </div>

    <!-- Status Info Modal -->
    <div id="status-modal" class="fixed inset-0 bg-black/90 z-[60] hidden flex items-center justify-center backdrop-blur-md animate-fade-in">
        <div class="bg-[#111] w-[500px] rounded-2xl p-8 border border-red-500/30 shadow-[0_0_50px_rgba(239,68,68,0.2)] relative overflow-hidden">
             <!-- Background warning stripe -->
            <div class="absolute top-0 left-0 w-full h-1 bg-gradient-to-r from-red-500 via-orange-500 to-red-500"></div>
            
            <div class="flex gap-5 items-start">
                <div class="w-12 h-12 rounded-full bg-red-500/10 flex items-center justify-center shrink-0 border border-red-500/20">
                    <svg class="w-6 h-6 text-red-500" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path></svg>
                </div>
                <div class="flex-1">
                    <h2 class="text-xl font-bold text-white mb-2">System Check Failed</h2>
                    <p class="text-gray-400 text-sm leading-relaxed mb-6">
                        The agent cannot be launched because one or more pre-flight checks failed. Please resolve the issues below.
                    </p>
                    
                    <!-- Error Details -->
                    <div class="space-y-3 mb-8" id="status-error-list">
                        <!-- Dynamic Errors injected here -->
                    </div>

                    <div class="flex gap-3 justify-end">
                        <button onclick="document.getElementById('status-modal').classList.add('hidden'); setLoading(false);" class="px-5 py-2.5 rounded-lg text-sm font-medium text-gray-400 hover:text-white hover:bg-white/5 transition">
                            Dismiss
                        </button>
                         <button onclick="checkStatus(); document.getElementById('status-modal').classList.add('hidden'); sendTask();" class="px-6 py-2.5 rounded-lg bg-red-500 hover:bg-red-600 text-white text-sm font-bold shadow-lg shadow-red-500/20 transition flex items-center gap-2">
                             <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path></svg>
                            Retry & Send
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Confirmation Modal -->
    <div id="confirm-modal" class="fixed inset-0 bg-black/90 z-[70] hidden flex items-center justify-center backdrop-blur-md animate-fade-in">
        <div class="bg-[#111] w-[400px] rounded-2xl p-6 border border-white/10 shadow-2xl relative">
            <h3 id="confirm-title" class="text-lg font-bold text-white mb-2">Confirm Action</h3>
            <p id="confirm-desc" class="text-gray-400 text-sm mb-6">Are you sure you want to proceed?</p>
            <div class="flex gap-3 justify-end">
                <button onclick="closeConfirm(false)" class="text-sm text-gray-400 hover:text-white transition px-4 py-2">Cancel</button>
                <button id="confirm-btn-yes" class="bg-red-500 text-white font-bold text-sm px-6 py-2 rounded-lg hover:bg-red-600 transition shadow-lg shadow-red-500/20">Confirm</button>
            </div>
        </div>
    </div>

<script>
    let profiles = [];
    let logCursor = 0;
    
    // --- Render Logic ---
    function renderProfiles() {
        const list = document.getElementById('profile-list');
        list.innerHTML = '<div class="text-[10px] text-gray-500 uppercase tracking-widest font-bold mb-3 ml-2">Service Profiles</div>';
        
        profiles.forEach((p, idx) => {
            const isActive = p.is_active;
            const card = document.createElement('div');
            card.className = `group relative p-3 rounded-xl transition-all duration-200 border cursor-pointer mb-2
                ${isActive ? 'bg-white/10 border-accent/40 shadow-[0_0_15px_-5px_#2CC985]' : 'bg-transparent border-transparent hover:bg-white/5 hover:border-white/10'}`;
            
            card.onclick = (e) => {
                if (e.target.closest('button')) return;
                activateProfile(idx);
            };

            card.innerHTML = `
                <div class="flex justify-between items-start">
                    <div>
                        <div class="text-sm font-bold ${isActive ? 'text-white' : 'text-gray-400 group-hover:text-gray-200'}">${p.name}</div>
                        <div class="text-[10px] text-gray-500 mt-0.5 font-mono bg-black/30 px-1.5 py-0.5 rounded inline-block">
                            ${p.provider || 'Auto'} ‚Ä¢ ${p.model}
                        </div>
                    </div>
                    ${isActive ? '<div class="w-2 h-2 rounded-full bg-accent animate-pulse-slow"></div>' : ''}
                </div>
                <div class="absolute right-2 top-8 flex gap-1 opacity-0 group-hover:opacity-100 transition-opacity">
                    <button onclick="openModal(${idx})" class="p-1.5 rounded hover:bg-white/20 text-gray-400 hover:text-white"><svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z"></path></svg></button>
                    <button onclick="deleteProfile(${idx})" class="p-1.5 rounded hover:bg-red-500/20 text-gray-400 hover:text-red-400"><svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg></button>
                </div>
            `;
            list.appendChild(card);
        });

        const active = profiles.find(p => p.is_active);
        if (active) {
            // Check if element exists before setting (safe check)
            const nameEl = document.getElementById('active-profile-name');
            if(nameEl) nameEl.textContent = active.name;
        }
    }

    // --- Actions ---
    function openModal(editIdx = -1) {
        const modal = document.getElementById('profile-modal');
        const title = document.getElementById('modal-title');
        document.getElementById('p-index').value = editIdx;
        
        modal.classList.remove('hidden');
        
        if (editIdx >= 0) {
            const p = profiles[editIdx];
            title.textContent = "Edit Service";
            document.getElementById('p-name').value = p.name;
            document.getElementById('p-provider').value = p.provider || "OpenAI";
            document.getElementById('p-url').value = p.base_url;
            document.getElementById('p-key').value = p.api_key;
            document.getElementById('p-model').value = p.model;
        } else {
            title.textContent = "Add Service";
            document.getElementById('p-name').value = "";
            document.getElementById('p-provider').value = "OpenAI";
            document.getElementById('p-url').value = "";
            document.getElementById('p-key').value = "";
            document.getElementById('p-model').value = "";
        }
    }

    async function saveProfile() {
        const idx = parseInt(document.getElementById('p-index').value);
        const name = document.getElementById('p-name').value;
        const provider = document.getElementById('p-provider').value;
        const url = document.getElementById('p-url').value;
        const key = document.getElementById('p-key').value;
        const model = document.getElementById('p-model').value;
        
        if (!name) return alert("Service Name is required");

        const newProfile = { name, provider, base_url: url, api_key: key, model, is_active: false };
        
        if (idx >= 0) {
            newProfile.is_active = profiles[idx].is_active;
            profiles[idx] = newProfile;
        } else {
            if (profiles.length === 0) newProfile.is_active = true;
            profiles.push(newProfile);
        }
        
        await updateServer();
        closeModal();
    }
    
    async function deleteProfile(idx) {
        if (!confirm("Delete?")) return;
        profiles.splice(idx, 1);
        await updateServer();
    }
    
    async function activateProfile(idx) {
        // Immediate Feedback: Set API status to Gray/Pulse
        const dotApi = document.getElementById('dot-api');
        if (dotApi) dotApi.className = 'w-1.5 h-1.5 rounded-full bg-gray-500 animate-pulse shadow-sm';
        
        profiles.forEach((p, i) => p.is_active = (i === idx));
        await updateServer();
        
        // Force re-check
        setTimeout(checkStatus, 500);
    }

    async function updateServer() {
        await fetch('/api/profiles', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(profiles)
        });
        renderProfiles();
    }

    // --- Task & UI Logic ---
    const btnSend = document.getElementById('btn-send');
    const btnStop = document.getElementById('btn-stop');
    const inputTask = document.getElementById('prompt-input');
    // const terminalDrawer = document.getElementById('terminal-drawer'); // Removed
    // const terminalArrow = document.getElementById('terminal-arrow'); // Removed
    // const terminalToggle = document.getElementById('terminal-toggle'); // Removed
    const logsContent = document.getElementById('logs-content');

    // let isTerminalOpen = false; // Removed

    // Terminal Toggle Logic - REMOVED


    // Auto-scroll logs
    const socket = new MutationObserver(() => {
        logsContent.scrollTop = logsContent.scrollHeight;
    });
    socket.observe(logsContent, { childList: true });

    function setNodeFailed(nodeId) {
        if (!nodeId) return;
        const node = document.getElementById(nodeId);
        if (!node) return;
        const statusContainer = node.querySelector('.status-marker');
        if (statusContainer) {
            statusContainer.innerHTML = '<svg class="w-4 h-4 text-red-500 animate-fade-in" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" /></svg>';
        }
    }

    async function stopTask() {
        if (!confirm("Stop current task?")) return;
        try {
            await fetch('/api/chat/stop', { method: 'DELETE' });
            setLoading(false);
            addBubble('system', 'Task stopped by user.');
            
            // Mark last node as failed/canceled
            if (lastActiveNodeId) {
                setNodeFailed(lastActiveNodeId);
                // Also deactivate line
                if (currentTaskContainer) {
                     currentTaskContainer.querySelector('.timeline-line').style.background = 'linear-gradient(to bottom, #ef4444, rgba(255,255,255,0.05))';
                     currentTaskContainer.classList.remove('active-task');
                }
                lastActiveNodeId = null;
                currentTaskContainer = null;
            }
        } catch(e) { alert(e); }
    }
    
    async function resetSession() {
        showConfirm("Reset Session", "Clear conversation logic and reset agent state?", async () => {
            try {
                await fetch('/api/chat/reset', { method: 'POST' });
                document.getElementById('chat-container').innerHTML = '';
                addBubble('system', 'Session Reset. Ready for new task.');
                setLoading(false); // Force reset state
                checkStatus(); // Refresh dots
            } catch(e) { alert(e); }
        });
    }

    // Modal Logic
    let confirmCallback = null;
    function showConfirm(title, desc, onConfirm) {
        document.getElementById('confirm-title').innerText = title;
        document.getElementById('confirm-desc').innerText = desc;
        document.getElementById('confirm-modal').classList.remove('hidden');
        confirmCallback = onConfirm;
        
        // Setup Yes Button
        const btn = document.getElementById('confirm-btn-yes');
        btn.onclick = () => { closeConfirm(true); };
    }

    function closeConfirm(isYes) {
        document.getElementById('confirm-modal').classList.add('hidden');
        if (isYes && confirmCallback) confirmCallback();
        confirmCallback = null;
    }
    
    if (btnStop) btnStop.onclick = stopTask;
    const btnRestart = document.getElementById('btn-restart');
    if (btnRestart) btnRestart.onclick = resetSession;

    function setLoading(loading) {
        if (loading) {
            btnSend.disabled = true;
            btnSend.innerHTML = '<svg class="animate-spin h-5 w-5 text-black" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>';
            btnSend.classList.add('opacity-50', 'cursor-not-allowed');
            btnStop.classList.remove('hidden');
        } else {
            console.log("Resetting Loading State");
            btnSend.disabled = false;
            btnSend.innerHTML = 'Send';
            btnSend.classList.remove('opacity-50', 'cursor-not-allowed');
            btnStop.classList.add('hidden');
            
            // Hide timeline loading indicator when task finishes
            const loadingIndicator = document.querySelector('.task-loading-indicator');
            if (loadingIndicator) {
                loadingIndicator.remove();
            }
        }
    }

    // Force unlock on load to fix stuck state
    setTimeout(() => setLoading(false), 500);
    
    // Add continue button after task failure
    function addContinueButton() {
        const container = document.getElementById('chat-container');
        if (!container) return;
        
        // Remove existing continue button if any
        const existing = document.querySelector('.continue-button-container');
        if (existing) existing.remove();
        
        const html = `
        <div class="continue-button-container flex gap-2 mt-4 animate-fade-in">
            <button onclick="continueTask()" class="flex-1 px-4 py-3 rounded-xl bg-gradient-to-r from-orange-500 to-red-500 text-white font-medium hover:opacity-90 transition-all flex items-center justify-center gap-2">
                <svg class="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z" />
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                </svg>
                ÁªßÁª≠‰ªªÂä°
            </button>
            <button onclick="resetAndNew()" class="px-4 py-3 rounded-xl glass-panel text-gray-300 hover:text-white transition-all">
                ÈáçÊñ∞ÂºÄÂßã
            </button>
        </div>`;
        container.insertAdjacentHTML('beforeend', html);
        container.scrollTop = container.scrollHeight;
    }
    
    // Continue the failed task
    window.continueTask = async function() {
        // Remove continue button
        const btn = document.querySelector('.continue-button-container');
        if (btn) btn.remove();
        
        // Create new timeline block for continuation
        createNewTaskBlock("ÁªßÁª≠‰πãÂâçÁöÑ‰ªªÂä°...");
        setLoading(true);
        
        // Send "continue" command to backend
        try {
            const response = await fetch('/api/chat/continue', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'}
            });
            const data = await response.json();
            console.log('Continue response:', data);
        } catch (e) {
            console.error('Continue failed:', e);
            setLoading(false);
        }
    };
    
    // Reset and start new task
    window.resetAndNew = function() {
        const btn = document.querySelector('.continue-button-container');
        if (btn) btn.remove();
        // Focus input for new task
        taskInput.focus();
    };

    function appendLogToTerminal(line) {
        const consoleEl = document.getElementById('logs-content');
        if (!consoleEl) return;
        const d = document.createElement('div');
        d.className = line.includes("ERROR") ? "text-red-400" : "text-gray-500 hover:text-gray-300";
        d.textContent = "> " + line;
        consoleEl.appendChild(d);
        consoleEl.scrollTop = consoleEl.scrollHeight;
    }

    // ========== Helper: Strip ANSI color codes ==========
    function stripAnsi(str) {
        return str.replace(/\x1b\[[0-9;]*m/g, '').replace(/\[0m/g, '').replace(/\[[\d;]*m/g, '');
    }
    
    // ========== Helper: Format action for title and details ==========
    function formatActionForDisplay(actionName, details) {
        // Returns {title: "Tap ‚Üí (50, 30)", detail: "ÂÆåÊï¥JSONÊàñnull"}
        const name = (actionName || 'unknown').toLowerCase();
        let titleSuffix = '';
        let detailText = null;
        
        try {
            const d = typeof details === 'string' ? JSON.parse(details) : (details || {});
            
            // Debug: log what we received
            console.log('[formatAction]', name, d);
            
            switch (name) {
                case 'tap':
                case 'double_tap':
                case 'double tap':
                case 'long_press':
                case 'long press':
                    const elem = d.element || d.position || [];
                    if (Array.isArray(elem) && elem.length >= 2) {
                        titleSuffix = `(${elem[0]}, ${elem[1]})`;
                    }
                    break;
                case 'type':
                    const txt = d.text || '';
                    titleSuffix = `"${txt.length > 20 ? txt.substring(0, 20) + '...' : txt}"`;
                    break;
                case 'wait':
                    titleSuffix = d.duration || '?';
                    break;
                case 'launch':
                    titleSuffix = d.app || '?';
                    break;
                case 'swipe':
                    const from = d.from || d.start || [];
                    const to = d.to || d.end || [];
                    if (from.length >= 2 && to.length >= 2) {
                        titleSuffix = `(${from[0]},${from[1]}) ‚Üí (${to[0]},${to[1]})`;
                    }
                    break;
                case 'take_over':
                    titleSuffix = 'ËØ∑Êìç‰ΩúÊâãÊú∫';
                    detailText = d.message || 'ÈúÄË¶ÅÁî®Êà∑ÂçèÂä©ÂÆåÊàêÊìç‰Ωú';
                    break;
                case 'finish':
                    // Finish action - show completion message
                    titleSuffix = d.message || 'ÂÆåÊàê';
                    break;
                case 'back':
                    titleSuffix = 'ËøîÂõû';
                    break;
                case 'home':
                    titleSuffix = '‰∏ªÂ±èÂπï';
                    break;
                case 'unknown':
                case 'do':
                    // Try to extract useful info from details
                    if (d.message) {
                        titleSuffix = d.message.length > 40 ? d.message.substring(0, 40) + '...' : d.message;
                    } else if (d.action && d.action !== 'unknown') {
                        // Recursively format if there's an inner action
                        return formatActionForDisplay(d.action, d);
                    }
                    break;
                default:
                    if (d.message) {
                        titleSuffix = d.message.length > 30 ? d.message.substring(0, 30) + '...' : d.message;
                    }
            }
            
            // Only show detail if there's meaningful extra info
            if (!detailText && Object.keys(d).length > 2) {
                detailText = JSON.stringify(d, null, 2);
            }
            
        } catch(e) {
            detailText = String(details);
        }
        
        // Build title - handle special display names
        let displayName = name.charAt(0).toUpperCase() + name.slice(1).replace(/_/g, ' ');
        if (name === 'finish') displayName = 'ÂÆåÊàê';
        if (name === 'unknown' || name === 'do') displayName = 'ÊâßË°å';
        
        const title = titleSuffix ? `${displayName} ‚Üí ${titleSuffix}` : displayName;
        
        return { title, detail: detailText };
    }
    
    // ========== State for deduplication ==========
    let lastBubbleType = null;
    let lastBubbleContent = null;
    let consecutiveThoughts = 0;
    let currentActiveBubble = null; // Track the current active thought bubble

    // === VERSION: 2024-12-14-v3 ===
    console.log('[AutoGLM] appendLogs loaded - VERSION 2024-12-14-v3');
    
    function appendLogs(logs) {
        logs.forEach(line => {
            if (!line) return;
            line = stripAnsi(line);
            if (!line.trim()) return;
            
            // Debug: log every incoming line
            console.log('[LOGS] Raw line:', line.substring(0, 100));
            
            let entry = null;
            try {
                if (line.trim().startsWith('{')) {
                    entry = JSON.parse(line);
                    console.log('[LOGS] Parsed entry:', entry.tag, entry.msg?.substring(0, 50));
                }
            } catch(e) {
                console.log('[LOGS] JSON parse failed:', e.message);
            }
            
            if (entry && entry.tag) {
                // Auto-recover currentTaskContainer if it's null
                if (!currentTaskContainer) {
                    const lastTimeline = document.querySelector('.timeline-container:last-child');
                    if (lastTimeline) {
                        currentTaskContainer = lastTimeline;
                        console.log('[DEBUG] Auto-recovered currentTaskContainer:', lastTimeline.id);
                    }
                }
                
                // 1. STREAM/THOUGHT -> Collapsible Thinking Card
                if (entry.tag === "STREAM" || entry.tag === "THOUGHT") {
                    const msgContent = (entry.msg || '').trim();
                    // Skip empty or invalid content
                    if (!msgContent || msgContent === '<answer>' || /^<\/?answer>+$/.test(msgContent)) {
                        return;
                    }
                    
                    // Append to active thinking card if exists
                    if (currentActiveBubble && document.contains(currentActiveBubble)) {
                        const contentEl = currentActiveBubble.querySelector('.thinking-content');
                        if (contentEl) contentEl.textContent += msgContent;
                        // Auto scroll
                        const chat = document.getElementById('chat-container');
                        if(chat) chat.scrollTop = chat.scrollHeight;
                        return;
                    }
                    
                    // Create new collapsible thinking card
                    const cardId = 'thinking-' + Date.now();
                    const card = document.createElement('div');
                    card.className = 'thinking-card collapsed mb-3 mx-4';
                    card.id = cardId;
                    card.innerHTML = `
                        <div class="card-header flex items-center gap-2 p-3 cursor-pointer rounded-xl bg-white/5 border border-white/10 hover:bg-white/10 transition-all" onclick="toggleThinkingCard('${cardId}')">
                            <span class="text-gray-400">üí≠</span>
                            <span class="text-sm text-gray-300 flex-1">Ê≠£Âú®ÊÄùËÄÉ...</span>
                            <span class="w-1.5 h-3 inline-block bg-green-500 animate-pulse"></span>
                            <svg class="w-4 h-4 text-gray-500 arrow-icon transition-transform" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" /></svg>
                        </div>
                        <div class="card-body hidden mt-2 p-3 rounded-xl bg-black/20 border border-white/5 text-gray-400 text-xs font-mono leading-relaxed max-h-60 overflow-y-auto custom-scrollbar">
                            <span class="thinking-content">${msgContent}</span>
                        </div>`;
                    
                    const timelineContainer = currentTaskContainer || document.getElementById('chat-container');
                    if (timelineContainer) {
                        timelineContainer.appendChild(card);
                        currentActiveBubble = card;
                    }
                    
                    // Auto scroll
                    const chat = document.getElementById('chat-container');
                    if(chat) chat.scrollTop = chat.scrollHeight;
                    return;
                }

                // 2. LOGS -> Bottom Terminal Drawer
                // Display non-Stream logs in terminal
                const consoleEl = document.getElementById('logs-content');
                if (consoleEl && entry.tag !== "STREAM") {
                    let colorClass = "text-gray-400";
                    if (entry.level === "ERROR") colorClass = "text-red-400 font-bold";
                    else if (entry.level === "WARN") colorClass = "text-yellow-400";
                    else if (entry.level === "AGENT") colorClass = "text-blue-400";
                    else if (entry.tag === "THOUGHT") colorClass = "text-gray-500 italic";
                    
                    const timeStr = new Date(entry.ts * 1000).toLocaleTimeString([], {hour12: false});
                    const lineStr = `[${timeStr}] ${entry.msg}`;
                    
                    const d = document.createElement('div');
                    d.className = `${colorClass} hover:text-gray-200 transition-colors border-b border-white/5 pb-1 mb-1`;
                    d.textContent = lineStr;
                    
                    if (entry.details && Object.keys(entry.details).length > 0) {
                        const det = document.createElement('div');
                        det.className = "text-[10px] text-gray-600 pl-4 overflow-hidden hidden font-mono mt-1";
                        det.textContent = JSON.stringify(entry.details, null, 2);
                        d.appendChild(det);
                        d.onclick = () => det.classList.toggle('hidden');
                        d.style.cursor = "pointer";
                    }
                    consoleEl.appendChild(d);
                    
                    // Only auto-scroll if near bottom
                    if (consoleEl.scrollHeight - consoleEl.scrollTop - consoleEl.clientHeight < 100) {
                        consoleEl.scrollTop = consoleEl.scrollHeight;
                    }
                }

                // 3. TIMELINE -> Task Nodes (Tools)
                // Note: THOUGHT tag is now redundant as specific node, because we use STREAM text bubbles.
                // We'll skip creating "THOUGHT" nodes and only rely on streams for thoughts.
                switch (entry.tag) {
                    case "ACTION":
                        console.log('[DEBUG] ACTION received:', entry.msg, entry.details);
                        consecutiveThoughts = 0;
                        
                        // Mark current thought bubble as completed (remove cursor, add class)
                        // Complete thinking card and clear reference
                        if (currentActiveBubble) {
                            // Remove pulse animation
                            const pulse = currentActiveBubble.querySelector('.animate-pulse');
                            if (pulse) pulse.classList.remove('animate-pulse');
                            // Update header text to show completion
                            const headerText = currentActiveBubble.querySelector('.text-sm');
                            if (headerText) headerText.textContent = 'üí≠ Â∑≤ÂÆåÊàêÊÄùËÄÉ';
                            currentActiveBubble = null;
                        }
                        
                        const actionName = entry.msg || 'unknown';
                        const actionData = entry.details?.action_details || entry.details;
                        const actionInfo = formatActionForDisplay(actionName, actionData);
                        console.log('[DEBUG] ACTION info:', actionInfo);
                        const actionKey = `${actionName}:${JSON.stringify(actionData)}`;
                        
                        if (lastBubbleType === 'tool' && lastBubbleContent === actionKey) return;
                        addBubbleWithDetail('tool', actionInfo.title, actionInfo.detail);
                        lastBubbleType = 'tool';
                        lastBubbleContent = actionKey;
                        break;
                        
                    case "RESULT":
                        consecutiveThoughts = 0;
                        // Complete thinking card if active
                        if (currentActiveBubble) {
                            const pulse = currentActiveBubble.querySelector('.animate-pulse');
                            if (pulse) pulse.classList.remove('animate-pulse');
                            const headerText = currentActiveBubble.querySelector('.text-sm');
                            if (headerText) headerText.textContent = 'üí≠ Â∑≤ÂÆåÊàêÊÄùËÄÉ';
                            currentActiveBubble = null;
                        }
                        const resultMsg = stripAnsi(entry.msg || '').trim();
                        if (lastBubbleType === 'ai' && lastBubbleContent === resultMsg) return;
                        addBubble('ai', resultMsg);
                        setLoading(false);
                        currentTaskContainer = null; // Task is done, reset container
                        lastBubbleType = 'ai';
                        lastBubbleContent = resultMsg;
                        break;
                    
                    case "TAKEOVER":
                        consecutiveThoughts = 0;
                        const takeoverMsg = stripAnsi(entry.msg || '').trim();
                        if (lastBubbleType === 'takeover' && lastBubbleContent === takeoverMsg) return;
                        addTakeOverNode("ËØ∑ÂçèÂä©ÂÆåÊàêÊìç‰Ωú", takeoverMsg);
                        setLoading(false);
                        lastBubbleType = 'takeover';
                        lastBubbleContent = takeoverMsg;
                        break;

                    case "FAILED":
                        consecutiveThoughts = 0;
                        const failedMsg = stripAnsi(entry.msg || '').trim();
                        addBubble('failed', failedMsg);
                        setLoading(false);
                        lastBubbleType = 'failed';
                        lastBubbleContent = failedMsg;
                        break;
                        
                    case "CANCELLED":
                        consecutiveThoughts = 0;
                        setLoading(false);
                        if (lastActiveNodeId) {
                            setNodeFailed(lastActiveNodeId);
                            lastActiveNodeId = null;
                        }
                        lastBubbleType = 'cancelled';
                        break;
                }
                
                if (entry.level === "ERROR") {
                    setLoading(false);
                    if (lastActiveNodeId) {
                        setNodeFailed(lastActiveNodeId);
                        lastActiveNodeId = null;
                    }
                }

            } else {
                // Legacy: String-based logs
                const cleanLine = stripAnsi(line);
                appendLogToTerminal(cleanLine);
                
                // Legacy Thought Extractor -> to Stream Bubble
                if (cleanLine.includes("üí≠")) {
                     const text = cleanLine.replace(/\[.*?\]/g, '').replace("üí≠", "").trim();
                     
                     const chatContainer = document.getElementById('chat-container');
                     const timelineContainer = currentTaskContainer || chatContainer;
                     if (timelineContainer) {
                         const bubbleHtml = `
                                <div class="thought-text-bubble flex gap-3 animate-fade-in mb-4 px-4 pl-12">
                                     <div class="flex-1">
                                         <div class="glass-panel p-3 px-4 rounded-xl rounded-tl-none bg-white/5 border border-white/5 text-gray-300 font-mono text-xs leading-relaxed shadow-lg">
                                             <span class="bubble-content">${text}</span>
                                         </div>
                                     </div>
                                </div>`;
                         timelineContainer.insertAdjacentHTML('beforeend', bubbleHtml);
                         const container = document.getElementById('chat-container');
                         if(container) container.scrollTop = container.scrollHeight;
                     }
                }
            }
        });
    }

    // Toggle Terminal Drawer with VS Code style slide up
    let isTerminalOpen = false;
    function toggleTerminal() {
        const drawer = document.getElementById('terminal-drawer');
        const inputContainer = document.getElementById('input-container');
        const mainLayout = document.getElementById('main-layout-area');
        
        isTerminalOpen = !isTerminalOpen;
        
        if (isTerminalOpen) {
            // Open: 
            // 1. Slide Drawer Up (0)
            drawer.style.transform = "translateY(0)";
            // 2. Input Up (-320px) 
            inputContainer.style.transform = "translateY(-300px)"; 
            // 3. Shrink Main View (Add 300px padding)
            if (mainLayout) mainLayout.style.paddingBottom = "400px"; 
            
            // Auto scroll chat to bottom to ensure "move up" feeling
            setTimeout(() => {
                const chat = document.getElementById('chat-container');
                if(chat) chat.scrollTop = chat.scrollHeight;
            }, 300); // Wait for transition
            
        } else {
            // Close: Reset
            drawer.style.transform = "translateY(120%)";
            inputContainer.style.transform = "translateY(0)";
            if (mainLayout) mainLayout.style.paddingBottom = "100px"; 
        }
    }

    // Keyboard Shortcut: Ctrl + \ to toggle logs
    document.addEventListener('keydown', (e) => {
        if (e.ctrlKey && e.key === '\\') {
            e.preventDefault();
            toggleTerminal();
        }
    });



                

                


    // --- Improved UI Logic ---
    let currentTaskContainer = null;
    let lastActiveNodeId = null;

    function createNewTaskBlock(userText) {
        lastActiveNodeId = null; // Reset for new task
        currentActiveBubble = null; // Reset active bubble for new task
        const container = document.getElementById('chat-container');
        
        // 1. User Header
        const userHtml = `
            <div class="flex gap-4 flex-row-reverse animate-fade-in group mb-2">
                <div class="w-8 h-8 rounded-full bg-white text-black flex items-center justify-center font-bold text-xs shrink-0 shadow-lg shadow-white/10">U</div>
                <div class="glass-panel p-3 px-5 rounded-2xl rounded-tr-none max-w-[85%] text-sm text-gray-200 shadow-md border-white/20">
                    <p>${userText}</p>
                </div>
            </div>`;
        container.insertAdjacentHTML('beforeend', userHtml);
        
        // 2. Timeline Container with loading indicator at the end
        const timelineId = 'timeline-' + Date.now();
        const timelineHtml = `
            <div id="${timelineId}" class="timeline-container active-task animate-fade-in">
                <div class="timeline-line"></div>
                <!-- Nodes appended here -->
                <!-- Loading indicator at the end -->
                <div id="${timelineId}-loading" class="task-loading-indicator flex items-center gap-3 pl-8 py-3 text-gray-500 text-xs">
                    <div class="w-5 h-5 border-2 border-gray-600 border-t-blue-400 rounded-full animate-spin"></div>
                    <span>Ê≠£Âú®Â§ÑÁêÜ‰∏≠...</span>
                </div>
            </div>`;
        container.insertAdjacentHTML('beforeend', timelineHtml);
        
        currentTaskContainer = document.getElementById(timelineId);
        container.scrollTop = container.scrollHeight;
    }

    function setNodeDone(nodeId) {
        if (!nodeId) return;
        const node = document.getElementById(nodeId);
        if (!node) return;
        const statusContainer = node.querySelector('.status-marker');
        if (statusContainer) {
            statusContainer.innerHTML = '<svg class="w-4 h-4 status-done animate-fade-in" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7" /></svg>';
        }
    }

    function addStepNode(type, title, details = null) {
        if (!currentTaskContainer) {
             const last = document.querySelector('.timeline-container:last-child');
             if (last) currentTaskContainer = last;
             if (last) {
                 const lastNode = last.querySelector('.task-node:last-child');
                 if(lastNode) lastActiveNodeId = lastNode.id;
             } else return;
        }

        if (lastActiveNodeId) setNodeDone(lastActiveNodeId);

        const nodeId = 'node-' + Date.now() + '-' + Math.floor(Math.random()*1000);
        let iconHtml = '';
        let typeClass = '';
        let colorClass = '';

        if (type === 'thought') {
            typeClass = 'type-thought';
            iconHtml = '<svg class="w-3.5 h-3.5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z" /></svg>';
            colorClass = 'text-gray-400';
        } else if (type === 'tool') {
            typeClass = 'type-tool';
            iconHtml = '<svg class="w-3.5 h-3.5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" /></svg>';
            colorClass = 'text-blue-400';
        } else if (type === 'ai') {
            typeClass = 'type-result';
            iconHtml = '<svg class="w-3.5 h-3.5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>';
            colorClass = 'text-green-400';
        } else if (type === 'failed') {
            typeClass = 'type-failed';
            iconHtml = '<svg class="w-3.5 h-3.5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>';
            colorClass = 'text-red-400';
        }

        const hasDetails = !!details;
        const isFinished = (type === 'ai' || type === 'failed'); // Result/Failed instantly done
        
        const html = `
        <div class="task-node ${typeClass} group" id="${nodeId}">
            <div class="node-connector ${type === 'tool' ? 'border-blue-500/50' : (type === 'thought' ? 'border-gray-600' : (type === 'failed' ? 'border-red-500' : 'border-green-500'))} bg-[#111]"></div>
            
            <div class="task-node-header" onclick="${hasDetails ? `toggleNode('${nodeId}')` : ''}">
                <div class="node-icon">
                    ${iconHtml}
                </div>
                <div class="flex-1 min-w-0 flex items-center gap-2">
                    <div class="text-xs font-medium ${colorClass} truncate">${title}</div>
                </div>
                
                <div class="status-marker">
                    ${type === 'thought'
                        ? '<div class="status-loading"></div>'  
                        : (type === 'failed' 
                            ? '<svg class="w-4 h-4 text-red-400" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" /></svg>'
                            : '<svg class="w-4 h-4 status-done" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7" /></svg>')
                    }
                </div>
                
                ${hasDetails ? '<svg class="w-3 h-3 text-gray-600 arrow-icon ml-2" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" /></svg>' : ''}
            </div>
            
            ${hasDetails ? `
            <div class="node-details text-gray-400 custom-scrollbar">
                <div class="whitespace-pre-wrap break-words opacity-80">${details}</div>
            </div>` : ''}
        </div>`;

        // Insert BEFORE loading indicator to keep it at the bottom
        const loadingIndicator = currentTaskContainer.querySelector('.task-loading-indicator');
        if (loadingIndicator) {
            loadingIndicator.insertAdjacentHTML('beforebegin', html);
        } else {
            currentTaskContainer.insertAdjacentHTML('beforeend', html);
        }
        
        lastActiveNodeId = isFinished ? null : nodeId;
        
        const container = document.getElementById('chat-container');
        container.scrollTop = container.scrollHeight;
        
        // Auto-open tools and results, keep thought closed?
        // Or simple: keep all closed to look clean, allow user to open.
        // Let's open Results by default.
        if (type === 'ai' && hasDetails) toggleNode(nodeId);
    }

    window.toggleNode = function(id) {
        const node = document.getElementById(id);
        const details = node.querySelector('.node-details');
        const arrow = node.querySelector('.arrow-icon');
        
        if (details.style.display === 'block') {
            details.style.display = 'none';
            arrow.style.transform = 'rotate(0deg)';
        } else {
            details.style.display = 'block';
            arrow.style.transform = 'rotate(90deg)';
        }
    }
    
    // Toggle thinking card expand/collapse
    window.toggleThinkingCard = function(id) {
        const card = document.getElementById(id);
        if (!card) return;
        
        const body = card.querySelector('.card-body');
        const arrow = card.querySelector('.arrow-icon');
        const header = card.querySelector('.card-header');
        
        if (card.classList.contains('collapsed')) {
            // Expand
            card.classList.remove('collapsed');
            body.classList.remove('hidden');
            if (arrow) arrow.style.transform = 'rotate(90deg)';
            // Update header text
            const headerText = header.querySelector('.text-sm');
            if (headerText) headerText.textContent = 'ÊÄùËÄÉËøáÁ®ã';
            // Remove pulse animation
            const pulse = header.querySelector('.animate-pulse');
            if (pulse) pulse.classList.remove('animate-pulse');
        } else {
            // Collapse
            card.classList.add('collapsed');
            body.classList.add('hidden');
            if (arrow) arrow.style.transform = 'rotate(0deg)';
        }
    }

    function addBubble(type, text) {
        // Legacy support / Wrapper
        if (type === 'user') {
            createNewTaskBlock(text);
            return;
        }
        
        // Clean text first
        const cleanText = stripAnsi(text || '').trim();
        if (!cleanText) return; // Skip empty content
        
        if (type === 'thought') {
            // Smart title: use first line or truncate
            let title = "ÊÄùËÄÉ‰∏≠...";
            let content = cleanText;
            
            // Extract first meaningful sentence
            const firstLine = content.split(/[„ÄÇ\n]/)[0].trim();
            if (firstLine && firstLine.length > 5) {
                title = firstLine.length > 60 ? firstLine.substring(0, 60) + "..." : firstLine;
            }
            
            // Only show details if there's more content
            const showDetails = content.length > 80;
            addStepNode('thought', title, showDetails ? content : null);
            
        } else if (type === 'tool') {
            let name = "ÊâßË°åÊìç‰Ωú";
            let details = null;
            
            // Parse "ActionName: details" format
            if (cleanText.includes(":")) {
                const colonIdx = cleanText.indexOf(":");
                const actionPart = cleanText.substring(0, colonIdx).trim();
                const detailPart = cleanText.substring(colonIdx + 1).trim();
                
                // Clean action name
                name = actionPart.replace("Use Tool:", "").trim();
                
                // Format details nicely
                if (detailPart) {
                    details = detailPart;
                }
            } else {
                name = cleanText;
            }
            
            addStepNode('tool', name, details);
            
        } else if (type === 'ai') {
            addStepNode('ai', '‰ªªÂä°ÂÆåÊàê', cleanText);
            // Mark timeline as complete
            const task = document.querySelector('.timeline-container.active-task');
            if (task) {
                task.querySelector('.timeline-line').style.background = 'linear-gradient(to bottom, #2CC985, #2CC985)';
                task.classList.remove('active-task');
            }
            setLoading(false);
        } else if (type === 'failed') {
            addStepNode('failed', '‚ùå ‰ªªÂä°Â§±Ë¥•', cleanText);
            // Mark timeline as failed
            const task = document.querySelector('.timeline-container.active-task');
            if (task) {
                task.querySelector('.timeline-line').style.background = 'linear-gradient(to bottom, #EF4444, #EF4444)';
                task.classList.remove('active-task');
                task.classList.add('failed-task');
            }
            setLoading(false);
            // Add continue button
            addContinueButton();
        } else if (type === 'system-check') {
            // Silently ignore
        }
    }
    
    // New: Add bubble with explicit title and detail (for structured actions)
    function addBubbleWithDetail(type, title, detail) {
        if (!title) return;
        
        const cleanTitle = stripAnsi(title || '').trim();
        const cleanDetail = detail ? stripAnsi(detail).trim() : null;
        
        if (type === 'tool') {
            // Check for Take_over - add confirmation button
            if (cleanTitle.toLowerCase().includes('take_over') || cleanTitle.includes('ËØ∑Êìç‰ΩúÊâãÊú∫')) {
                addTakeOverNode(cleanTitle, cleanDetail);
            } else {
                addStepNode('tool', cleanTitle, cleanDetail);
            }
        } else if (type === 'thought') {
            addStepNode('thought', cleanTitle, cleanDetail);
        } else if (type === 'ai') {
            addStepNode('ai', cleanTitle, cleanDetail);
        }
    }
    
    // Special node for Take_over with confirmation button
    function addTakeOverNode(title, message) {
        if (!currentTaskContainer) {
            const last = document.querySelector('.timeline-container:last-child');
            if (last) currentTaskContainer = last;
            else return;
        }
        
        if (lastActiveNodeId) setNodeDone(lastActiveNodeId);
        
        const nodeId = 'takeover-' + Date.now();
        const html = `
        <div class="task-node type-takeover group" id="${nodeId}">
            <div class="node-connector border-yellow-500/50 bg-[#111]"></div>
            
            <div class="task-node-header">
                <div class="node-icon">
                    <svg class="w-3.5 h-3.5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" /></svg>
                </div>
                <div class="flex-1 min-w-0">
                    <div class="text-xs font-medium text-yellow-400">${title}</div>
                    ${message ? `<div class="text-xs text-gray-500 mt-1">${message}</div>` : ''}
                </div>
                <div class="status-marker">
                    <div class="status-loading"></div>
                </div>
            </div>
            
            <div class="p-3 pt-0">
                <button onclick="confirmTakeOver('${nodeId}')" class="w-full py-2 px-4 bg-yellow-600/80 hover:bg-yellow-500 text-white text-xs font-medium rounded-lg transition-colors">
                    ‚úì ÊàëÂ∑≤ÂÆåÊàêÊìç‰ΩúÔºåÁªßÁª≠ÊâßË°å
                </button>
            </div>
        </div>`;
        
        currentTaskContainer.insertAdjacentHTML('beforeend', html);
        lastActiveNodeId = nodeId;
        
        const container = document.getElementById('chat-container');
        container.scrollTop = container.scrollHeight;
    }
    
    // Handle Take_over confirmation
    window.confirmTakeOver = async function(nodeId) {
        setNodeDone(nodeId);
        
        // Notify backend to continue
        try {
            await fetch('/api/takeover_confirm', { method: 'POST' });
        } catch(e) {
            console.log('Takeover confirm sent');
        }
    }
    
    // Send Task Logic with Pre-flight Check
    async function sendTask() {
        const tasks = inputTask.value.trim();
        if (!tasks) return;
        
        // 1. Initial UI State
        addBubble('user', tasks);
        const userTask = tasks; // Keep ref
        inputTask.value = '';
        setLoading(true); 
        
        // 2. Pre-flight Check
        const checkBubble = addBubble('system-check', 'Checking system status...');
        const status = await checkStatus(true); // Return status object
        
        // 3. Validation Logic
        const errors = [];
        if (!status.adb) errors.push({title: "ADB Connection Failed", desc: "No Android device detected via ADB."});
        if (!status.api) errors.push({title: "API Service Unavailable", desc: "Cannot connect to the LLM API provider."});
        if (status.agent === 'busy') errors.push({title: "Agent Busy", desc: "The agent is currently executing another task."});
        
        if (errors.length > 0) {
            // FAILED: Show Modal
            setLoading(false); // Reset UI loading immediately
            showStatusErrors(errors);
            if (checkBubble) checkBubble.remove(); 
            return;
        }

        // Success: Remove checking bubble
        if (checkBubble) checkBubble.remove();

        // 4. Success -> Send
        try {
            await fetch('/api/chat', { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({task: userTask}) });
        } catch(e) { 
            alert(e); 
            setLoading(false); 
        }
    }
    
    function showStatusErrors(errors) {
        const list = document.getElementById('status-error-list');
        list.innerHTML = '';
        errors.forEach(err => {
            const item = document.createElement('div');
            item.className = "bg-red-500/5 border border-red-500/10 rounded-lg p-3 flex gap-3 items-start";
            item.innerHTML = `
                <svg class="w-5 h-5 text-red-500 shrink-0 mt-0.5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                <div>
                    <div class="text-red-400 font-bold text-xs uppercase tracking-wider mb-1">${err.title}</div>
                    <div class="text-gray-400 text-xs">${err.desc}</div>
                </div>
            `;
            list.appendChild(item);
        });
        document.getElementById('status-modal').classList.remove('hidden');
    }

    // Init
    if (inputTask)    inputTask.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            if (btnSend.disabled) {
                e.preventDefault(); // Prevent default if disabled
                return;
            }
            if (!e.shiftKey) { // Allow Shift+Enter for new line
                e.preventDefault();
                sendTask();
            }
        }
    });window.closeModal = function() { document.getElementById('profile-modal').classList.add('hidden'); }
    window.openModal = openModal; window.saveProfile = saveProfile; window.deleteProfile = deleteProfile;
    window.activateProfile = activateProfile; window.sendTask = sendTask;
    window.checkStatus = checkStatus;
    
    if (typeof marked === 'undefined') {
        const s = document.createElement('script');
        s.src = "https://cdn.jsdelivr.net/npm/marked/marked.min.js";
        document.head.appendChild(s);
    }

    async function fetchProfiles() { try { const res = await fetch('/api/profiles'); profiles = await res.json(); renderProfiles(); } catch (e) {} }
    
    async function checkStatus(returnData = false) {
        try { const res = await fetch('/api/status'); const status = await res.json();
            // V3 Header Dots Sync
            // IDs: dot-adb, dot-api, dot-agent (defined in header)
            const hDotAdb = document.getElementById('dot-adb');
            const hDotApi = document.getElementById('dot-api');
            const hDotAgent = document.getElementById('dot-agent');
            const hTextAgent = document.getElementById('text-agent');
            
            if (hDotAdb) hDotAdb.className = `w-1.5 h-1.5 rounded-full transition-colors duration-500 ${status.adb ? 'bg-green-500 shadow-[0_0_8px_#22c55e]' : 'bg-red-500'}`;
            if (hDotApi) {
                let apiClass = 'bg-gray-500 animate-pulse'; // Default/Null
                if (status.api === true) apiClass = 'bg-green-500 shadow-[0_0_8px_#22c55e]';
                else if (status.api === false) apiClass = 'bg-red-500';
                
                hDotApi.className = `w-1.5 h-1.5 rounded-full transition-colors duration-500 ${apiClass}`;
            }
            
            if (hDotAgent) {
                if (status.agent === 'busy') {
                     hDotAgent.className = 'w-1.5 h-1.5 rounded-full bg-yellow-400 animate-pulse shadow-[0_0_8px_#facc15]';
                     if (hTextAgent) { 
                         hTextAgent.innerText = 'BUSY'; 
                         hTextAgent.className = 'text-[10px] uppercase font-bold text-yellow-500 tracking-wider'; 
                     }
                     // Sync Lock State
                     if (!btnSend.disabled) setLoading(true);
                } else {
                     const isReady = status.agent === 'ready';
                     hDotAgent.className = `w-1.5 h-1.5 rounded-full transition-colors duration-500 ${isReady ? 'bg-green-500 shadow-[0_0_8px_#22c55e]' : 'bg-gray-600'}`;
                     if (hTextAgent) {
                        hTextAgent.innerText = isReady ? 'READY' : 'OFFLINE';
                        hTextAgent.className = `text-[10px] uppercase font-bold tracking-wider ${isReady ? 'text-gray-200' : 'text-gray-400'}`;
                     }
                }
            }

             if (returnData) return status;

        } catch (e) {
            if (returnData) return { adb: false, api: false, agent: 'offline' };
        }
    }
    
    async function pollLogs() {
        try { const res = await fetch(`/api/logs?since=${logCursor}`); const data = await res.json();
            if (data.logs.length > 0) { appendLogs(data.logs); logCursor = data.next_cursor; }
        } catch(e) {} setTimeout(pollLogs, 1000);
    }
    
    // ============================================================================
    // Remote Control Logic
    // ============================================================================
    const overlay = document.getElementById('control-overlay');
    const inputPopover = document.getElementById('text-input-popover');
    const remoteInput = document.getElementById('remote-input');
    
    let isDragging = false;
    let startX = 0, startY = 0;
    let startTime = 0;
    
    if (overlay) {
        // Touch/Mouse Start
        const onStart = (e) => {
            e.preventDefault();
            isDragging = false;
            const pt = getPoint(e);
            startX = pt.x;
            startY = pt.y;
            startTime = Date.now();
        };
        
        // Touch/Mouse Move
        const onMove = (e) => {
            if (e.buttons === 0 && e.type !== 'touchmove') return; 
            const pt = getPoint(e);
            const dist = Math.hypot(pt.x - startX, pt.y - startY);
            if (dist > 0.02) isDragging = true; // Threshold ~2% of width
        };
        
        // Touch/Mouse End
        const onEnd = async (e) => {
            const pt = getPoint(e, true); // Use last known point
            const duration = Date.now() - startTime;
            
            if (isDragging) {
                // Swipe
                console.log('Swipe:', startX, startY, '->', pt.x, pt.y);
                await apiCall('/api/control/swipe', {
                    start_x: startX, start_y: startY,
                    end_x: pt.x, end_y: pt.y,
                    duration: Math.min(Math.max(duration, 100), 1000)
                });
            } else {
                // Tap
                console.log('Tap:', startX, startY);
                // Visual feedback
                showTapEffect(e);
                await apiCall('/api/control/tap', { x: startX, y: startY });
            }
            isDragging = false;
        };
        
        overlay.addEventListener('mousedown', onStart);
        overlay.addEventListener('mousemove', onMove);
        overlay.addEventListener('mouseup', onEnd);
        
        overlay.addEventListener('touchstart', onStart);
        overlay.addEventListener('touchmove', onMove);
        overlay.addEventListener('touchend', onEnd);
    }
    
    function getPoint(e, isEnd = false) {
        const rect = overlay.getBoundingClientRect();
        let clientX, clientY;
        
        if (e.changedTouches && e.changedTouches.length > 0) {
            clientX = e.changedTouches[0].clientX;
            clientY = e.changedTouches[0].clientY;
        } else {
            clientX = e.clientX;
            clientY = e.clientY;
        }
        
        // Normalize 0.0 - 1.0
        const x = (clientX - rect.left) / rect.width;
        const y = (clientY - rect.top) / rect.height;
        return { x: Math.max(0, Math.min(1, x)), y: Math.max(0, Math.min(1, y)) }; // Clamp
    }
    
    function showTapEffect(e) {
        const rect = overlay.getBoundingClientRect();
        let x, y;
        if (e.changedTouches) {
             x = e.changedTouches[0].clientX - rect.left;
             y = e.changedTouches[0].clientY - rect.top;
        } else {
             x = e.clientX - rect.left;
             y = e.clientY - rect.top;
        }
        
        const ripple = document.createElement('div');
        ripple.className = 'absolute bg-white/50 rounded-full w-8 h-8 pointer-events-none animate-ping';
        ripple.style.left = (x - 16) + 'px';
        ripple.style.top = (y - 16) + 'px';
        overlay.appendChild(ripple);
        setTimeout(() => ripple.remove(), 500);
    }
    
    // --- API Helpers ---
    async function apiCall(url, data) {
        try {
            await fetch(url, {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify(data)
            });
        } catch(e) { console.error('Control Error:', e); }
    }
    
    window.sendKey = async function(keycode) {
        await apiCall('/api/control/key', { keycode });
    }
    
    window.toggleTextInput = function() {
        if (inputPopover.classList.contains('hidden')) {
            inputPopover.classList.remove('hidden');
            remoteInput.focus();
        } else {
            inputPopover.classList.add('hidden');
        }
    }
    
    window.sendTextInput = async function() {
        const text = remoteInput.value;
        if (text) {
            await apiCall('/api/control/input', { text });
            remoteInput.value = '';
            toggleTextInput();
        }
    }
    
    if (remoteInput) {
        remoteInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') sendTextInput();
        });
    }

    fetchProfiles(); 
    checkStatus();
    setInterval(checkStatus, 1000); // Heartbeat
    pollLogs();



</script>
</body>
</html>
